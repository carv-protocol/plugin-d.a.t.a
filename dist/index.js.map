{"version":3,"sources":["../src/providers/ethereum/ethereumData.ts","../src/index.ts"],"sourcesContent":["import {\n    Provider,\n    IAgentRuntime,\n    Memory,\n    State,\n    elizaLogger,\n    generateMessageResponse,\n    ModelClass,\n    stringToUuid,\n    getEmbeddingZeroVector,\n    generateObject,\n    composeContext,\n} from \"@elizaos/core\";\nimport { z } from \"zod\";\n\n// API response interface for query results\nexport interface IQueryResult {\n    success: boolean;\n    data: any[];\n    metadata: {\n        total: number;\n        queryTime: string;\n        queryType: \"transaction\" | \"token\" | \"aggregate\" | \"unknown\";\n        executionTime: number;\n        cached: boolean;\n        pagination?: {\n            currentPage: number;\n            totalPages: number;\n            hasMore: boolean;\n        };\n    };\n    analysis?: string;\n    error?: {\n        code: string;\n        message: string;\n        details?: any;\n    };\n}\n\n// API response interface\ninterface IApiResponse {\n    code: number;\n    msg: string;\n    data: {\n        column_infos: string[];\n        rows: {\n            items: (string | number)[];\n        }[];\n    };\n}\n\nexport interface IAnalysisResult {\n    context: string;\n    queryResult: IQueryResult;\n}\n\nexport class DatabaseProvider {\n    private chain: string;\n    private readonly API_URL: string;\n    private readonly AUTH_TOKEN: string;\n    private readonly DATA_PROVIDER_ANALYSIS: boolean;\n    constructor(chain: string, runtime: IAgentRuntime) {\n        this.chain = chain;\n        this.API_URL = runtime.getSetting(\"DATA_API_KEY\");\n        this.AUTH_TOKEN = runtime.getSetting(\"DATA_AUTH_TOKEN\");\n        this.DATA_PROVIDER_ANALYSIS =\n            runtime.getSetting(\"DATA_PROVIDER_ANALYSIS\") === \"true\";\n    }\n    getProviderAnalysis(): boolean {\n        return this.DATA_PROVIDER_ANALYSIS;\n    }\n\n    public extractSQLQuery(preResponse: any): string | null {\n        try {\n            // Try to parse if input is string\n            let jsonData = preResponse;\n            if (typeof preResponse === \"string\") {\n                try {\n                    jsonData = JSON.parse(preResponse);\n                } catch (e) {\n                    elizaLogger.error(\n                        \"Failed to parse preResponse as JSON:\",\n                        e\n                    );\n                    return null;\n                }\n            }\n\n            // Function to recursively search for SQL query in object\n            const findSQLQuery = (obj: any): string | null => {\n                // Base cases\n                if (!obj) return null;\n\n                // If string, check if it's a SQL query\n                if (typeof obj === \"string\") {\n                    const sqlPattern = /^\\s*(SELECT|WITH)\\s+[\\s\\S]+?(?:;|$)/i;\n                    const commentPattern = /--.*$|\\/\\*[\\s\\S]*?\\*\\//gm;\n\n                    // Clean and check the string\n                    const cleanStr = obj.replace(commentPattern, \"\").trim();\n                    if (sqlPattern.test(cleanStr)) {\n                        // Validate SQL safety\n                        const unsafeKeywords = [\n                            \"drop\",\n                            \"delete\",\n                            \"update\",\n                            \"insert\",\n                            \"alter\",\n                            \"create\",\n                        ];\n                        const isUnsafe = unsafeKeywords.some((keyword) =>\n                            cleanStr.toLowerCase().includes(keyword)\n                        );\n\n                        if (!isUnsafe) {\n                            return cleanStr;\n                        }\n                    }\n                    return null;\n                }\n\n                // If array, search each element\n                if (Array.isArray(obj)) {\n                    for (const item of obj) {\n                        const result = findSQLQuery(item);\n                        if (result) return result;\n                    }\n                    return null;\n                }\n\n                // If object, search each value\n                if (typeof obj === \"object\") {\n                    for (const key of Object.keys(obj)) {\n                        // Prioritize 'query' field in sql object\n                        if (key.toLowerCase() === \"query\" && obj.sql) {\n                            const result = findSQLQuery(obj[key]);\n                            if (result) return result;\n                        }\n                    }\n\n                    // Search other fields\n                    for (const key of Object.keys(obj)) {\n                        const result = findSQLQuery(obj[key]);\n                        if (result) return result;\n                    }\n                }\n\n                return null;\n            };\n\n            // Start the search\n            const sqlQuery = findSQLQuery(jsonData);\n\n            if (!sqlQuery) {\n                elizaLogger.warn(\"No valid SQL query found in preResponse\");\n                return null;\n            }\n            return sqlQuery;\n        } catch (error) {\n            elizaLogger.error(\"Error in extractSQLQuery:\", error);\n            return null;\n        }\n    }\n\n    private async sendSqlQuery(sql: string): Promise<IApiResponse> {\n        try {\n            const url = `${this.API_URL}/sql_query`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: this.AUTH_TOKEN ? `${this.AUTH_TOKEN}` : \"\",\n                },\n                body: JSON.stringify({\n                    sql_content: sql,\n                }),\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const data = await response.json();\n            return data as IApiResponse;\n        } catch (error) {\n            elizaLogger.error(\"Error sending SQL query to API:\", error);\n            throw error;\n        }\n    }\n\n    // Transform API response data\n    private transformApiResponse(apiResponse: IApiResponse): any[] {\n        const { column_infos, rows } = apiResponse.data;\n\n        return rows.map((row) => {\n            const rowData: Record<string, any> = {};\n            row.items.forEach((value, index) => {\n                const columnName = column_infos[index];\n                rowData[columnName] = value;\n            });\n            return rowData;\n        });\n    }\n\n    // Execute query\n    private async executeQuery(sql: string): Promise<IQueryResult> {\n        try {\n            // Validate query\n            if (!sql || sql.length > 5000) {\n                throw new Error(\"Invalid SQL query length\");\n            }\n\n            const queryType = sql.toLowerCase().includes(\"token_transfers\")\n                ? \"token\"\n                : sql.toLowerCase().includes(\"count\")\n                  ? \"aggregate\"\n                  : \"transaction\";\n\n            // Send query to API\n            const apiResponse = await this.sendSqlQuery(sql);\n\n            // Check API response status\n            if (apiResponse.code !== 0) {\n                throw new Error(`API Error: ${apiResponse.msg}`);\n            }\n\n            // Transform data\n            const transformedData = this.transformApiResponse(apiResponse);\n\n            const queryResult: IQueryResult = {\n                success: true,\n                data: transformedData,\n                metadata: {\n                    total: transformedData.length,\n                    queryTime: new Date().toISOString(),\n                    queryType: queryType as\n                        | \"token\"\n                        | \"aggregate\"\n                        | \"transaction\",\n                    executionTime: 0,\n                    cached: false,\n                },\n            };\n\n            return queryResult;\n        } catch (error) {\n            elizaLogger.error(\"Query execution failed:\", error);\n            return {\n                success: false,\n                data: [],\n                metadata: {\n                    total: 0,\n                    queryTime: new Date().toISOString(),\n                    queryType: \"unknown\",\n                    executionTime: 0,\n                    cached: false,\n                },\n                error: {\n                    code: error.code || \"EXECUTION_ERROR\",\n                    message: error.message || \"Unknown error occurred\",\n                    details: error,\n                },\n            };\n        }\n    }\n\n    public async query(sql: string): Promise<IQueryResult> {\n        return this.executeQuery(sql);\n    }\n\n    getDatabaseSchema(): string {\n        return `\n        CREATE EXTERNAL TABLE transactions(\n            hash string,\n            nonce bigint,\n            block_hash string,\n            block_number bigint,\n            block_timestamp timestamp,\n            date string,\n            transaction_index bigint,\n            from_address string,\n            to_address string,\n            value double,\n            gas bigint,\n            gas_price bigint,\n            input string,\n            max_fee_per_gas bigint,\n            max_priority_fee_per_gas bigint,\n            transaction_type bigint\n        ) PARTITIONED BY (date string)\n        ROW FORMAT SERDE 'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'\n        STORED AS INPUTFORMAT 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'\n        OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat';\n\n        CREATE EXTERNAL TABLE token_transfers(\n            token_address string,\n            from_address string,\n            to_address string,\n            value double,\n            transaction_hash string,\n            log_index bigint,\n            block_timestamp timestamp,\n            date string,\n            block_number bigint,\n            block_hash string\n        ) PARTITIONED BY (date string)\n        ROW FORMAT SERDE 'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'\n        STORED AS INPUTFORMAT 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'\n        OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat';\n        `;\n    }\n\n    getQueryExamples(): string {\n        return `\n        Common Query Examples:\n\n        1. Find Most Active Addresses in Last 7 Days:\n        WITH address_activity AS (\n            SELECT\n                from_address AS address,\n                COUNT(*) AS tx_count\n            FROM\n                eth.transactions\n            WHERE date_parse(date, '%Y-%m-%d') >= date_add('day', -7, current_date)\n            GROUP BY\n                from_address\n            UNION ALL\n            SELECT\n                to_address AS address,\n                COUNT(*) AS tx_count\n            FROM\n                eth.transactions\n            WHERE\n                date_parse(date, '%Y-%m-%d') >= date_add('day', -7, current_date)\n            GROUP BY\n                to_address\n        )\n        SELECT\n            address,\n            SUM(tx_count) AS total_transactions\n        FROM\n            address_activity\n        GROUP BY\n            address\n        ORDER BY\n            total_transactions DESC\n        LIMIT 10;\n\n        2. Analyze Address Transaction Statistics (Last 30 Days):\n        WITH recent_transactions AS (\n            SELECT\n                from_address,\n                to_address,\n                value,\n                block_timestamp,\n                CASE\n                    WHEN from_address = :address THEN 'outgoing'\n                    WHEN to_address = :address THEN 'incoming'\n                    ELSE 'other'\n                END AS transaction_type\n            FROM eth.transactions\n            WHERE date >= date_format(date_add('day', -30, current_date), '%Y-%m-%d')\n                AND (from_address = :address OR to_address = :address)\n        )\n        SELECT\n            transaction_type,\n            COUNT(*) AS transaction_count,\n            SUM(CASE WHEN transaction_type = 'outgoing' THEN value ELSE 0 END) AS total_outgoing_value,\n            SUM(CASE WHEN transaction_type = 'incoming' THEN value ELSE 0 END) AS total_incoming_value\n        FROM recent_transactions\n        GROUP BY transaction_type;\n\n        3. Token Transfer Analysis:\n        WITH filtered_transactions AS (\n            SELECT\n                token_address,\n                from_address,\n                to_address,\n                value,\n                block_timestamp\n            FROM eth.token_transfers\n            WHERE token_address = :token_address\n                AND date >= :start_date\n        )\n        SELECT\n            COUNT(*) AS transaction_count,\n            SUM(value) AS total_transaction_value,\n            MAX(value) AS max_transaction_value,\n            MIN(value) AS min_transaction_value,\n            MAX_BY(from_address, value) AS max_value_from_address,\n            MAX_BY(to_address, value) AS max_value_to_address,\n            MIN_BY(from_address, value) AS min_value_from_address,\n            MIN_BY(to_address, value) AS min_value_to_address\n        FROM filtered_transactions;\n\n        Note: Replace :address, :token_address, and :start_date with actual values when querying.\n        `;\n    }\n\n    getQueryTemplate(): string {\n        return `\n        # Database Schema\n        {{databaseSchema}}\n\n        # Query Examples\n        {{queryExamples}}\n\n        # User's Query\n        {{userQuery}}\n\n        # Query Guidelines:\n        1. Time Range Requirements:\n           - ALWAYS include time range limitations in queries\n           - Default to last 3 months if no specific time range is mentioned\n           - Use date_parse(date, '%Y-%m-%d') >= date_add('month', -3, current_date) for default time range\n           - Adjust time range based on user's specific requirements\n\n        2. Query Optimization:\n           - Include appropriate LIMIT clauses\n           - Use proper indexing columns (date, address, block_number)\n           - Consider partitioning by date\n           - Add WHERE clauses for efficient filtering\n\n        3. Response Format Requirements:\n           You MUST respond in the following JSON format:\n           {\n             \"sql\": {\n               \"query\": \"your SQL query string\",\n               \"explanation\": \"brief explanation of the query\",\n               \"timeRange\": \"specified time range in the query\"\n             },\n             \"analysis\": {\n               \"overview\": {\n                 \"totalTransactions\": \"number\",\n                 \"timeSpan\": \"time period covered\",\n                 \"keyMetrics\": [\"list of important metrics\"]\n               },\n               \"patterns\": {\n                 \"transactionPatterns\": [\"identified patterns\"],\n                 \"addressBehavior\": [\"address analysis\"],\n                 \"temporalTrends\": [\"time-based trends\"]\n               },\n               \"statistics\": {\n                 \"averages\": {},\n                 \"distributions\": {},\n                 \"anomalies\": []\n               },\n               \"insights\": [\"key insights from the data\"],\n               \"recommendations\": [\"suggested actions or areas for further investigation\"]\n             }\n           }\n\n        4. Analysis Requirements:\n           - Focus on recent data patterns\n           - Identify trends and anomalies\n           - Provide statistical analysis\n           - Include risk assessment\n           - Suggest further investigations\n\n        Example Response:\n        {\n          \"sql\": {\n            \"query\": \"WITH recent_txs AS (SELECT * FROM eth.transactions WHERE date_parse(date, '%Y-%m-%d') >= date_add('month', -3, current_date))...\",\n            \"explanation\": \"Query fetches last 3 months of transactions with aggregated metrics\",\n            \"timeRange\": \"Last 3 months\"\n          },\n          \"analysis\": {\n            \"overview\": {\n              \"totalTransactions\": 1000000,\n              \"timeSpan\": \"2024-01-01 to 2024-03-12\",\n              \"keyMetrics\": [\"Average daily transactions: 11000\", \"Peak day: 2024-02-15\"]\n            },\n            \"patterns\": {\n              \"transactionPatterns\": [\"High volume during Asian trading hours\", \"Weekend dips in activity\"],\n              \"addressBehavior\": [\"5 addresses responsible for 30% of volume\", \"Increasing DEX activity\"],\n              \"temporalTrends\": [\"Growing transaction volume\", \"Decreasing gas costs\"]\n            },\n            \"statistics\": {\n              \"averages\": {\n                \"dailyTransactions\": 11000,\n                \"gasPrice\": \"25 gwei\"\n              },\n              \"distributions\": {\n                \"valueRanges\": [\"0-1 ETH: 60%\", \"1-10 ETH: 30%\", \">10 ETH: 10%\"]\n              },\n              \"anomalies\": [\"Unusual spike in gas prices on 2024-02-01\"]\n            },\n            \"insights\": [\n              \"Growing DeFi activity indicated by smart contract interactions\",\n              \"Whale addresses showing increased accumulation\"\n            ],\n            \"recommendations\": [\n              \"Monitor growing gas usage trend\",\n              \"Track new active addresses for potential market signals\"\n            ]\n          }\n        }\n        `;\n    }\n\n    getAnalysisInstruction(): string {\n        return `\n            1. Data Overview:\n                - Analyze the overall pattern in the query results\n                - Identify key metrics and their significance\n                - Note any unusual or interesting patterns\n\n            2. Transaction Analysis:\n                - Examine transaction values and their distribution\n                - Analyze gas usage patterns\n                - Evaluate transaction frequency and timing\n                - Identify significant transactions or patterns\n\n            3. Address Behavior:\n                - Analyze address interactions\n                - Identify frequent participants\n                - Evaluate transaction patterns for specific addresses\n                - Note any suspicious or interesting behavior\n\n            4. Temporal Patterns:\n                - Analyze time-based patterns\n                - Identify peak activity periods\n                - Note any temporal anomalies\n                - Consider seasonal or cyclical patterns\n\n            5. Token Analysis (if applicable):\n                - Examine token transfer patterns\n                - Analyze token holder behavior\n                - Evaluate token concentration\n                - Note significant token movements\n\n            6. Statistical Insights:\n                - Provide relevant statistical measures\n                - Compare with typical blockchain metrics\n                - Highlight significant deviations\n                - Consider historical context\n\n            7. Risk Assessment:\n                - Identify potential suspicious activities\n                - Note any unusual patterns\n                - Flag potential security concerns\n                - Consider regulatory implications\n\n            Please provide a comprehensive analysis of the Ethereum blockchain data based on these ethereum information.\n            Focus on significant patterns, anomalies, and insights that would be valuable for understanding the blockchain activity.\n            Use technical blockchain terminology and provide specific examples from the data to support your analysis.\n\n            Note: This analysis is based on simulated data for demonstration purposes.\n        `;\n    }\n\n    private getAnalysisTemplate(): string {\n        return `\nPlease analyze the provided Ethereum blockchain data and generate a comprehensive analysis report. Focus on the following aspects:\n\n1. Transaction Overview\n- Total number of transactions and time period covered\n- Block range and statistics (unique blocks, average transactions per block)\n- Success rate and overall transaction patterns\n- Notable trends or anomalies in the dataset\n\n2. Value Analysis\n- Total and average ETH value transferred\n- Distribution of transaction values\n- Significant value transfers\n- Token transfer patterns (if applicable)\n\n3. Gas and Network Analysis\n- Gas usage patterns (average, total, distribution)\n- Gas price trends and fee market conditions\n- Network congestion indicators\n- Transaction efficiency metrics\n\n4. Address Activity\n- Unique addresses and their roles\n- Most active participants (senders/receivers)\n- Contract interactions and patterns\n- Notable address behaviors\n\n5. Technical Insights\n- Transaction type distribution\n- Input data patterns and complexity\n- Smart contract interactions\n- Special transaction characteristics\n\n6. Risk and Security\n- Unusual patterns or anomalies\n- Potential security concerns\n- Notable address behaviors\n- Regulatory considerations\n\nPlease provide a natural language analysis that:\n- Uses professional blockchain terminology\n- Highlights significant patterns and anomalies\n- Provides specific examples from the data\n- Draws meaningful conclusions about network usage\n- Includes relevant statistical measures\n- Notes any unusual or suspicious activities\n\nTransaction Data:\n{{transactionData}}\n\nQuery Metadata:\n{{queryMetadata}}\n`;\n    }\n\n    // Schema for analysis result using zod\n    private analysisSchema = z.object({\n        summary: z.string().describe(\"Overall summary of the query results\"),\n        analysis: z\n            .array(\n                z.object({\n                    aspect: z.string().describe(\"Analysis dimension or aspect\"),\n                    content: z.string().describe(\"Detailed analysis content\"),\n                })\n            )\n            .describe(\"Multiple analysis dimensions\"),\n        insights: z.array(z.string()).describe(\"Key findings and insights\"),\n    });\n\n    public async analyzeQuery(\n        queryResult: IQueryResult,\n        message: Memory,\n        runtime: IAgentRuntime,\n        state: State\n    ): Promise<string> {\n        try {\n            if (!queryResult?.data || !queryResult?.metadata) {\n                elizaLogger.warn(\"Invalid query result for analysis\");\n                return null;\n            }\n\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n\n            elizaLogger.log(\"%%%% D.A.T.A analysis start\");\n\n            elizaLogger.log(\n                `%%%% D.A.T.A queryResult: ${JSON.stringify(queryResult, null, 2)}`\n            );\n\n            const template = `\n            # User Query\n            ${message.content.text}\n\n            # Query Result\n            ${JSON.stringify(queryResult, null, 2)}\n\n            # Analysis Instructions\n            Please analyze the above Ethereum blockchain data with focus on:\n            1. Overall situation summary\n            2. Detailed analysis of various aspects (transactions, value transfers, gas usage, address activities, etc.)\n            3. Key findings and insights\n\n            Requirements:\n            - Use clear and accessible language\n            - Highlight significant and anomalous patterns\n            - Freely organize analysis dimensions\n            - Consider data correlations\n            - Include relevant metrics where appropriate\n            `;\n\n            const context = composeContext({\n                state,\n                template,\n            });\n\n            elizaLogger.log(\"%%%% generateObject...\");\n\n            const analysisResponse = await generateObject({\n                runtime,\n                context: context,\n                modelClass: ModelClass.LARGE,\n                schema: this.analysisSchema,\n            });\n\n            // elizaLogger.log(\"%%%% D.A.T.A. analysisResponse\", analysisResponse);\n\n            // Format analysis results\n            if (analysisResponse?.object) {\n                const obj = analysisResponse.object as Record<string, any>;\n                const analysisText = [\n                    \"Summary:\",\n                    obj.summary,\n                    \"\",\n                    ...(obj.analysis || [])\n                        .map((item) => [`${item.aspect}:`, item.content, \"\"])\n                        .flat(),\n                    obj.insights?.length ? \"Key Findings:\" : \"\",\n                    ...(obj.insights || []).map((insight) => `• ${insight}`),\n                ]\n                    .filter((line) => line !== \"\")\n                    .join(\"\\n\");\n\n                return analysisText;\n            }\n\n            return null;\n        } catch (error) {\n            elizaLogger.error(\"Error in analyzeQuery:\", error);\n            return null;\n        }\n    }\n\n    public async processD_A_T_AQuery(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ): Promise<IAnalysisResult | null> {\n        try {\n            const schema = this.getDatabaseSchema();\n            const examples = this.getQueryExamples();\n            const template = this.getQueryTemplate();\n\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n\n            const buildContext = template\n                .replace(\"{{databaseSchema}}\", schema)\n                .replace(\"{{queryExamples}}\", examples)\n                .replace(\"{{userQuery}}\", message.content.text || \"\");\n\n            const context = JSON.stringify({\n                user: runtime.agentId,\n                content: buildContext,\n                action: \"NONE\",\n            });\n\n            const preResponse = await generateMessageResponse({\n                runtime: runtime,\n                context: context,\n                modelClass: ModelClass.LARGE,\n            });\n\n            const userMessage = {\n                agentId: runtime.agentId,\n                roomId: message.roomId,\n                userId: message.userId,\n                content: message.content,\n            };\n\n            // Save response to memory\n            const preResponseMessage: Memory = {\n                id: stringToUuid(message.id + \"-\" + runtime.agentId),\n                ...userMessage,\n                userId: runtime.agentId,\n                content: preResponse,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: Date.now(),\n            };\n\n            await runtime.messageManager.createMemory(preResponseMessage);\n            await runtime.updateRecentMessageState(state);\n\n            // Check for SQL query in the response using class method\n            const sqlQuery = this.extractSQLQuery(preResponse);\n            if (sqlQuery) {\n                elizaLogger.log(\"%%%% D.A.T.A Generated SQL query:\", sqlQuery);\n                const analysisInstruction = this.getAnalysisInstruction();\n                try {\n                    // Call query method on provider\n                    const queryResult = await this.query(sqlQuery);\n\n                    elizaLogger.log(\n                        \"%%%% D.A.T.A. queryResult\",\n                        queryResult.success\n                    );\n\n                    // Return combined context with query results and analysis instructions\n                    const context = `\n                    # query by user\n                    ${message.content.text}\n\n                    # query result\n                    ${JSON.stringify(queryResult, null, 2)}\n\n                    # Analysis Instructions\n                    ${analysisInstruction}\n                    `;\n                    return {\n                        context: context,\n                        queryResult: queryResult,\n                    };\n                } catch (error) {\n                    elizaLogger.error(\"Error executing query:\", error);\n                    return null;\n                }\n            } else {\n                elizaLogger.log(\"no sql query found in user message\");\n            }\n            return null;\n        } catch (error) {\n            elizaLogger.error(\"Error in processD_A_T_AQuery:\", error);\n            return null;\n        }\n    }\n}\n\nexport const databaseProvider = (runtime: IAgentRuntime) => {\n    const chain = \"ethereum-mainnet\";\n    return new DatabaseProvider(chain, runtime);\n};\n\nexport const ethereumDataProvider: Provider = {\n    get: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ): Promise<string | null> => {\n        try {\n            const provider = databaseProvider(runtime);\n            if (!provider.getProviderAnalysis()) {\n                return null;\n            }\n            const result = await provider.processD_A_T_AQuery(\n                runtime,\n                message,\n                state\n            );\n            if (result) {\n                return result.context;\n            }\n            return null;\n        } catch (error) {\n            elizaLogger.error(\"Error in ethereum data provider:\", error);\n            return null;\n        }\n    },\n};\n","import { Plugin } from \"@elizaos/core\";\nimport { fetchTransactionAction } from \"./actions/fetchTransaction\";\nimport { fetchTokenInfoAction } from \"./actions/fetchTokenInfo\";\nimport { ethereumDataProvider } from \"./providers/ethereum/ethereumData\";\nimport { tokenInfoProvider } from \"./providers/token/tokenInfo\";\nimport { twitterBalanceAction } from \"./actions/carv/twitterBalance\";\nimport { twitterBalanceProvider } from \"./providers/carv/twitterBalance\";\n\nexport const onchainDataPlugin: Plugin = {\n    name: \"onchain data plugin\",\n    description: \"Enables onchain data fetching\",\n    actions: [],\n    providers: [ethereumDataProvider],\n    evaluators: [],\n    services: [],\n    clients: [],\n};\n"],"mappings":"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","names":["context"]}